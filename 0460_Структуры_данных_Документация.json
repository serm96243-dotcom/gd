{
  "title": "Структуры данных",
  "text": "Была ли статья полезной?\nДа\nНет\nСпасибо за вашу оценку!\nОставляя более подробный отзыв, вы помогаете нам улучшать документацию\nКомментарий к оценке\nКонтактная информация (необязательно)\nВложения\nДобавить файл\nОтменить\nОтправить\nСтруктуры данных\nДля алгоритмических действий могут быть полезны временные структуры данных. Такие структуры позволяют алгоритму зафиксировать в оперативной памяти набор элементов (скалярных значений, объектов, экземпляров) и организовать циклы перебора или обработки данных. Структуры относятся к возможностям языка Groovy и предполагают преимущественно ручной набор кода.\nРазновидности структур\nТерминологически на языке программистов структуры данных могут именоваться множеством способов: \"массивами\", \"многомерными массивами\", \"динамическими списками\", \"хэш-таблицами\", \"ассоциативными массивами\", \"наборами данных\", \"списками\", \"хэшами\" и пр.\nВсе структуры имеют функциональные особенности и содержат элементы.\nЭлементом\nструктуры может быть не только скалярное значение (например, число 120), но и объект Системы любого типа (например, экземпляр заявки) или другая вложенная структура.\nСмысловые структуры данных\nНа уровне методов решений прикладных задач принципиально разными смысловыми структурами данных являются:\nмассив\n– структура с доступом к элементам по индексу;\nхэш\n– структура, обеспечивающая доступ по уникальным ключам;\nочередь\n– содержит методы \"добавить в конец\" и \"взять из начала\";\nстек\n– обслуживает методы \"добавить вверх\" и \"взять сверху\";\nнаправленный список\n– состоит из элементов со ссылкой на другой элемент;\nдерево\n– структура с набором указателей на различные элементы.\nФизические структуры\nНа уровне реализации смысловые структуры являются сочетанием физической структуры и специализированных методов. Для действий аналитиков принципиально важно понимание следующих структур:\nстатические массивы\n– содержат фиксированное количество элементов;\nдинамические массивы\n– расширяемые наборы могут пополняться и менять состав элементов;\nхэши/ассоциативные массивы\n– состоят из элементов, доступных по уникальным ключам, могут модифицироваться.\nВ практике автоматизации настоятельно рекомендуется использовать именно динамические структуры, способные к изменению состава элементов (поддерживающие пополнение и удаление).\nПрограммный код реализующий работу со структурами может быть записан несколькими способами. В примерах этой статьи приводится самый компактный способ записи алгоритмических директив.\nСтатический массив\nДоступ к элементам статического массива предполагает предварительное объявление размерности массива с явным указанием количества элементов. При необходимости заявленная размерность статического массива может быть получена свойством\nlength\n.\nНаиболее универсальным является массив типа\nObject\n, так как в нем могут размещаться элементы любого типа. Указание иных типов (например, String) означает, что все элементы массива будут соответствовать указанному типу.\nОбратите внимание, что заполнение массива предполагает обращение к его элементам в режиме присваивания, а не вызов методов добавления. Элементы массива, которые не были заполнены значениями, считаются пустыми.\nПример манипуляций с данными статического массива\ndef d1 := new Object[5]\nd1[0] := 100\nd1[1] := 200\nd1[4] := 500\nprintout (\" Структура: \" + d1)\nprintout (\" Элемент с индексом 1: \" + d1[1])\nprintout (\" Всего элементов: \" + d1.length)\nПеребор элементов массива выполняется арифметическим циклом от стартового до конечного элемента.\nПример циклической обработки типизированного массива (типа String)\ndef arr := new String[3]\narr[0] := \"Москва\"\narr[1] := \"Пермь\"\narr[2] := \"Омск\"\nprintout (\"--- Стартовый массив ---\")\nprintout (\"Массив как структура: \" + arr)\nprintout (\"--- Цикл по элементам ---\")\nfor(def i := 0; i < arr.length; i++) {\nprintout (\"Элемент с индексом \" + i + \": \" + arr[i])\n}\nВ многомерных массивах доступ к элементам выполняется через составной индекс. При этом для циклического перебора элементов часто используются вложенные циклы.\nПример циклического заполнения двухмерного массива (заполнение таблицы умножения 10*10)\ndef arr0 := new Object[10][10]\nprintout(\"--- Вложенные циклы маccива ---\")\nfor(def i=0; i<arr0.size(); i++){\nfor(def j=0; j<arr0[i].size(); j++){\narr0[i][j] :=  (i+1)*(j+1)\n}\n}\nЦиклы обработки могут эффективно использоваться и для других типов массивов.\nДинамический массив\nДинамический (расширяемый) массив предоставляет возможность изменения состава элементов, для чего предусмотрены методы:\nadd\n– добавление элемента в массив;\nremove\n– уничтожение элемента (с пересмотром порядка следования);\nsize\n– метод получения актуальной размерности (кол-ва элементов).\nПример манипуляций с данными динамического массива\ndef arr := []\narr.add(\"Москва\")\narr.add(\"Екатеринбург\")\narr.add(\"Пермь\")\nprintout (\"--- Первичный массив ---\")\nprintout (arr)\nprintout (\"Всего элементов: \" + arr.size())\nprintout (\"Элемент по индексу 1: \" + arr[1])\narr.add(\"Тюмень\")\narr.remove(\"Екатеринбург\")\nprintout (\"--- Модифицированный массив ---\")\nprintout (arr)\nprintout (\"--- Реверсированный массив ---\")\narr := arr.reverse()\nprintout (arr)\nПример вложенного массива (эмуляция многомерности)\ndef arr1 := []\ndef arr2 := []\narr2.add(\"Пермь\")\narr2.add(\"Кунгур\")\narr2.add(\"Оса\")\narr1.add(\"Уральский ФО\")\narr1.add(arr2)\narr1.add(arr2)\narr1[1][1] := \"новый\"\narr1.add(\"Центральный ФО\")\narr1.add(\"Южный ФО\")\nprintout (\"--- Результирующая стуктура ---\")\nprintout (\"Основной массив: \" + arr1)\nprintout (\"Стартовый элемент: \" + arr1[0])\nprintout (\"Элементов в основном наборе: \" + arr1.size())\nprintout (\"--- Вложенный массив ---\")\nprintout (\"Состав массива: \" + arr1[1])\nprintout (\"Всего элементов: \" + arr1[1].size())\nprintout (\"Центральный элемент: \" + arr1[1][1])\nХэш\nПри организации данных в хэш (хэш-таблицу) используется класс\nHashSet\n, позволяющий обслуживать\nуникальный\nи неупорядоченный набор элементов. Ключевыми методами работы являются:\nadd\n– добавление уникального элемента;\nremove\n– удаление существующего элемента.\nСледует обратить особое внимание именно на правило соблюдения уникальности набора данных.\nТак, например, попытка вставить в хэш эквивалент (дубликат) существующего элемента не может быть исполнена и будет проигнорирована.\nПример коррекции состава простейшего хэша\ndef hs := new HashSet()\nhs.add(\"Москва\")\nhs.add(\"Пермь\")\nhs.add(\"Екатеринбург\")\nhs.add(\"Тюмень\")\nprintout (\"--- Стартовый состав ---\")\nprintout (hs)\nhs.add(\"Пермь\")\nhs.remove(\"Тюмень\")\nprintout (\"--- Измененный состав ---\")\nprintout (hs)\nАссоциативный массив\nОсобым техническим видом набора данных HashSet является набор\nHashMap\n, который предполагает манипуляции с элементами именно по их уникальным ключам и опирается на методы:\nput\n– добавление элемента (ключ и значение);\nget\n– получение элемента (по ключу).\nПри обработке данных хэша используется специализированный цикл \"для каждого элемента\", позволяющий извлечь ключ и значение элемента по актуальному ключу.\nПример работы с данными (по ключам) в структуре HashMap\ndef hm := new HashMap()\nhm.put(495, \"Москва\")\nhm.put(342, \"Пермь\")\nhm.put(3812, \"Омск\")\nhm.put(3452, \"Тюмень\")\nprintout (\"--- Первичная структура ---\")\nprintout (hm)\nprintout (\"--- Цикл перебора элементов ---\")\nfor(def elem : hm) {\nprintout (elem)\nprintout (\"Пара \" + elem.key + \" и \" + elem.value)\n}\nprintout (\"--- Цикл доступа по ключам ---\")\nfor(def k : hm.keySet()) {\nprintout (\"Для ключа \" + k + \" значение \" + hm.get(k))\n}\nСтек\nРабота с данными в режиме стека предполагает объявление расширяемого массива\nArrayDeque\n. При этом используются специализированные методы:\npush\n– добавление элементов в стек;\npop\n– извлечение элемента.\nПример работы расширяемого массива в режиме стека\ndef st := new ArrayDeque()\nst.push(\"Москва\")\nst.push(\"Екатеринбург\")\nst.push(\"Пермь\")\nprintout (\"--- Исходный стек ---\")\nprintout (st)\ndef elemcount := st.size()\nprintout (\"Количество элементов: \" + elemcount)\ndef elem := st.pop()\nprintout (\"--- Модифицированный стек ---\")\nprintout (st)\nprintout (\"Извлеченный элемент: \" + elem)\nprintout (\"Стартовый элемент: \" + st[0])\nprintout (\"Актуальное количество: \" + st.size())\nОчередь\nРабота с данными в режиме очереди предполагает объявление расширяемого массива\nArrayDeque\n. При этом используются специализированные методы:\noffer\n– добавление элементов в конец очереди;\npoll\n– извлечение элемента из начала очереди.\nПример работы расширяемого массива в режиме очереди\ndef st := new ArrayDeque()\nst.offer(\"Москва\")\nst.offer(\"Екатеринбург\")\nst.offer(\"Пермь\")\nprintout (\"--- Стартовая очередь ---\")\nprintout (st)\ndef elemcount := st.size()\nprintout (\"Количество элементов: \" + elemcount)\ndef elem := st.poll()\nprintout (\"--- Модифицированная очередь ---\")\nprintout (st)\nprintout (\"Извлеченный элемент: \" + elem)\nprintout (\"Актуальное количество: \" + st.size())\nprintout (\"--- Доступ к элементам ---\")\nprintout (\"Начальный элемент: \" + st.getFirst())\nprintout (\"Концевой элемент: \" + st.getLast())\nprintout (\"Элемент с индексом 0: \" + st[0])\nПри использовании методов getFirst() и getLast() в расширяемом методе\nArrayDeque\nнедопустимо наличие пустого значения.\nПоиск и проверка\nПроверка данных на принадлежность набору и прочие поисковые действия в структурах данных могут выполняться несколькими способами, которые зависят от первоначально выбранной физической структуры.\nПоиск по массивам выполняется с помощью директив:\ncontains\n– содержится ли в наборе данных;\nin\n– входит ли в состав массива;\nindexOf\n– позиция вхождения.\nprintout(\"--- Поиск по массиву ---\")\ndef arr := []\narr.add(\"Москва\")\narr.add(\"Пермь\")\nif(arr.contains(\"Пермь\")){\nprintout(\"Элемент найден\")\n}\nif(!arr.contains(\"Омск\")){\nprintout(\"Такого в массиве не нашлось\")\n}\nif(\"Москва\" in arr){\nprintout(\"Элемент имеется внутри\")\n}\nprintout(\"Позиция найденного элемента: \" + arr.indexOf(\"Пермь\"))\nprintout(\"Позиция НЕнайденного элемента: \" + arr.indexOf(\"Киров\"))\nДля поиска по хэш структурам предназначены методы:\ncontainsKey\n– содержится ли элемент (по ключу);\ncontainsValue\n– содержится ли элемент (по значению).\ndef hm := new HashMap()\nhm.put(495, \"Москва\")\nhm.put(342, \"Пермь\")\nif(hm.containsKey(342)){\nprintout(\"Элемент по ключу найден\")\n}\nif(hm.containsValue(\"Москва\")){\nprintout(\"Элемент по значению найден\")\n}\nprintout(\"--- Проверка и обновление элемента ---\")\nif(hm.containsKey(342)){\nif(hm[342] = \"Пермь\"){\nhm[342] := \"город \"+hm[342]\n}\n}\nprintout(hm)",
  "source": "https://docs.greendata.ru/platform/ru/data-structures.html"
}