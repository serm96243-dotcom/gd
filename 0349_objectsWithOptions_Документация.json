{
  "title": "objectsWithOptions",
  "text": "Was this article helpful?\nYes\nNo\nThank you for rating the article!\nBy leaving more detailed feedback, you help us improve the documentation\nComment on the rating\nContact information (optional)\nAttachments\nAdd file\nCancel\nSubmit\nobjectsWithOptions\nReturns a collection of objects of the specified type with filtering.\nMost often used in loops when declaring a variable ( type collection).\nSyntax\n1. Syntax of a function with extended functionality:\nobjectsOptions(objects, SearchOptions.create()\n.fields(attr)\n.filterAlg(filter).filterSource(filter).filterTree(filter)\n.addSort(sortAttr, sortType, nullOrder)\nProviding the algorithm with attributes for initialization and sorting, as well as filtering conditions, is done\noptionally\nvia search settings methods (SearchOptions).\nThe details of using the methods are presented in the settings table.\nSetting\nPurpose\nobjects\nObject type whose collection of objects is returned.\nThe object type (or its ID) can be passed as a numeric value or using the\nparam\n,\ndict\nor\nvar\nfunctions as a parameter, directory value or variable.\nattr\nType attributes for initialization.\nAttributes are provided to the search settings via the\nfields\nmethod, where attributes are enumerated using commas.\nExample of writing\nfields\nmethod.\nAdded “Author” and “Date of application” as attributes for initialization of the “Application” object type:\nobjectsOptions(Application, SearchOptions.create().fields(Author, Date of application)\nThe use of the fields method is optional. When using the method, the “attr” parameter is required.\nfilter\nFiltering objects that can be customized in several ways: filter algorithm, SQL condition, or\ncondition tree\n.\nEach filtering instance is provided to the search settings via the corresponding method,\nfilterAlg\n,\nfilterSource\n, or\nfilterTree\n.\nWhen adding filtering by multiple methods, the data will be filtered by the rule of combining all specified filtering methods.\nExample of writing\nfilterAlg\n,\nfilterSource\n, and\nfilterTree\nmethods.\nFiltering of objects by the “Algorithm for filtering the object type ”Application“ object type”, the SQL-condition “Filtering applications by executor” and the condition tree “Condition for filtering the application status” will be written as follows:\nobjectsOptions(Application, SearchOptions.create().filterAlg(Algorithm for filtering the object type “Application”).filterSource(Filtering applications by executor).filterTree(Condition for filtering the request status)\nA tree/data source/algorithm object can be passed to the filter method as a numeric value or using the\nparam\n,\ndict\n, or\nvar\nfunctions as a parameter, directory value or variable.\nThe use of filterAlg, filterSource and filterTree methods is optional. When using method(s), the “filter” parameter is required.\nsortAttr\nType attribute for sorting, which is provided to the search settings as the first parameter of the\naddSort\nmethod.\nAttribute types to which sorting cannot be applied:\n“Child object”;\n“Custom”;\n“Object” with the “Multiple choice” option active;\n“Object” with “Multiple choice” option disabled and “Multiple objects as table (full list)” visual;\n“File”;\n“Primitive”.\nSorting by multiple attributes is realized by adding a method with a set of parameters .addSort(sortAttr, sortType, nullOrder) for each attribute.\nSorting is performed according to the adding order.\nFirst, the data is sorted by the first attribute, then by the second one taking into account sorting by the first attribute and so on - sorting by each subsequent attribute is performed taking into account the already applied sorting.\nExample of writing\naddSort\nmethod.\nAs attributes for sorting, “Date of application” and “Critical” of the object type “Application” are added:\nobjectsOptions(Application, SearchOptions.create().addSort( Date of application, 'DESC', 'NULLS_LAST').addSort(Critical, 'ASC', 'NULLS_FIRST')\nApplication of the addSort method is optional. When using the method, the “sortAttr” parameter is required.\nsortType\nSorting type that is provided to the search settings as the second parameter of the\naddSort\nmethod.\nThe parameter is provided as\ntext\nwith the value:\nASC – sorting in ascending order;\nDESC - sorting in descending order.\nParameter is not required.\nnullOrder\nOrder in which to display empty values, which is passed to the search settings as the second parameter of the\naddSort\nmethod.\nThe parameter is passed as\ntext\nwith the value:\nNULLS_FIRST - empty values are displayed at the beginning of the list;\nNULLS_LAST - empty values are displayed at the end of the list.\nParameter is not required.\n2. Syntax of a function with truncated functionality:\nobjectsWithOptions\n(typeObj, filter, [attr])\nSetting\nPurpose\ntypeObj\nObject type whose collection of objects (instances) is returned.\nThe object type (or its ID) can be passed as a numeric value or using the\nparam\n,\ndict\nor\nvar\nfunctions as a parameter, directory value or variable.\nfilter\nFiltering objects using a filtering algorithm, data source or condition tree.\nFiltering of objects is done using the\nfilterAlg\n,\nfilterSource\nor\nfilterTree\nfunction.\nA tree/source/algorithm object can be passed as a parameter value using the\nparam\n,\ndict\n, or\nvar\nfunctions.\nattr\nType attributes for initialization, specified after filtering objects.\nNot a required parameter.\nNote\nThe function is called from the\n“Sources”\nor\n“Algorithms”\ntab of the Algorithm Editor toolbar.\nWhen calling the function, a modal window will open to get a collection of objects by type with the ability to customize filtering and sorting:\nSetting up the function involves:\nIn the “Object type” field select the type of objects for which the collection of objects is to be retrieved.\nTo speed up the algorithm execution on the “Attributes for initialization” tab, the attributes of the type that are going to be used inside the loop can be defined.\nIn this case, the database will be queried once.\nIf the initialization attributes are not selected, a database query will be performed each time the attribute is accessed within the loop.\nThe list of initialization attributes is created in the right table by moving the necessary type attributes from the left table (the selection of parent type attributes is available when the switch is active) using the buttons\nor using Drag&Drop method.\nFiltering is configured on the \"Filtering\" tab by selecting or creating filtering algorithm, SQL condition and/or condition tree parameters via the actions menu.\nSelection of filtering parameters values is done from the drop-down list, where there are the following options available:\nfiltering algorithms with an unfilled basic object type or the type specified as the “Object type” parameter when setting up the function;\nSQL filters with the object type specified when setting up the function;\ncondition trees with an unfilled basic object type or the type specified as the “Object type” parameter when setting up the function.\nSorting is configured on the \"Sorting\" tab.\nThe list of attributes for sorting is created in the right table by moving the necessary attributes of the type from the left table (selection of parent type attributes is available when the switch is active) using the\nor using Drag&Drop method.\nFor the attributes in the right table the following can be defined:\nsorting type - ASC (ascending sorting) / DESC (descending sorting);\nASC value is used by default._\norder of displaying empty values - NULL_FIRST (empty values are displayed at the beginning of the list) / NULL_LAST (empty values are displayed at the end of the list);\nThe default value is NULL_LAST.\nattributes order using the\nbuttons in the table control panel, according to which sorting will be performed.\nAfter clicking on the “Done” button, the following is pasted into the algorithm code:\ndef searchOptions = SearchOptions.create()\nobjectsOptions (objects, searchOptions)\nWhere “searchOptions” is the default declared variable through which the optional search settings are provided.\nUse examples\nExample 1\nFor example,  there is an enrollment for basketball classes for boys born in 2015 and 2016. From the applications received, lists need to be generated by sorting children by date of birth and last name.\nThe algorithm can be as follows:\nTo write the algorithm, the objectsWithOptions function is called, when setting it up, the “Forms” object type is selected. As attributes for initialization\nthe attributes used in the algorithm are added:\nThe \"Filtering\" tab adds\nSQL condition\nto filter objects by year of birth and\ncondition tree\nto filter objects by gender:\nOn the “Sorting” tab, the “Date of birth” and “Last name” attributes are added to the right table.\nThis order will sort the objects first by date of birth, and if there are identical dates, sorting will be done by last name.\nThe default order of displaying empty values is used for added attributes.\nChanging the sorting type of date of birth will allow to display forms in descending order.\nAfter clicking on the “Done” button, the following will be pasted into the algorithm code.\nOther functions were also used to write this algorithm.\nTo output the result of the\nobjectsWithOptions\nfunction to the algorithm log using the\nprintout\nfunction, a loop through the collection can be added using the\nforEach\nfunction and\nvariable\nrez.\nThe\nprintout\nfunction adds the required attributes with the spacing specified with\ntext\nvia\nattrByVar\n.\nImagine that the application registry contains the following forms (boys born in 2015 and 2016 are highlighted):\nAs a result of the algorithm execution, data corresponding to the specified filters and sorting will be recorded in the algorithm operation log:\nExample 2\nExample of setting up a function with truncated functionality.\nIt is necessary to generate a list of Security Department employees celebrating birthdays in the upcoming month.\nThe algorithm may be implemented as follows:\nThe collection of  \"User\" object type is set by the\nobjectsWithOptions\nfunction, which uses the\nfilterAlg\nfunction to select a previously created algorithm for filtering users belonging to the Security Department access group:\nTo verify users membership in \"Security Department\" access group, the\nuserHasGroup\nfunction is used.\nOther functions were also used to create this algorithm.\nMore.\nNew variables are declared using the\nvar\nfunction.\nThe next month’s number is obtained using the\ngetMonth\n,\nplusMonths\n, and\ncurrentDate\nfunctions.\nTo find employees celebrating birthdays, a\nforEach\nloop is used, where the object collection is provided by the [objectsWithOptions] function.\nTo compare user birth\nmonth\nand next month number, the\nif\noperator is used.\nThe \"Birthdate\" and \"Name\" attributes are added using\nattrByVar\n.\nAlgorithm execution results are logged via\nprintout\nwith\ntext\nformatting.\nAs a result of the algorithm, the generated list will be displayed in the log:",
  "source": "https://docs.greendata.ru/platform/en/objectswithoptions.html"
}