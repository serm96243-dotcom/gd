{
  "title": "Интеграция на примере систем планирования и тикетов",
  "text": "Была ли статья полезной?\nДа\nНет\nСпасибо за вашу оценку!\nОставляя более подробный отзыв, вы помогаете нам улучшать документацию\nКомментарий к оценке\nКонтактная информация (необязательно)\nВложения\nДобавить файл\nОтменить\nОтправить\nИнтеграция на примере систем планирования и тикетов\nВ рамках данной статьи рассматривается пример\nинтеграции\nна базе систем планирования и тикетов.\nСистема планирования\n- это система учета всех задач, с которыми работают продуктовые команды. Данные в систему планирования\nпереносятся\nв тип объекта \"Git.Task\" [GIT_TASK] посредством настроенного\nETL-процесса\nс сайта\ngitlab.greendatasoft.ru\n. Приложение, на котором реализована система планирования, обозначим как\nПриложение A\n.\nСистема тикетов\n- это система учета обращений партнеров.\nТикеты\n- это обращения партнеров по вопросам, связанным с функциональностью Low - Code платформы GreenData. Приложение, на котором реализована система тикетов, обозначим как\nПриложение B\n.\nВ случае, когда возникает необходимость передать обращение партнера в работу продуктовой команде компании Greendata, на сайте\ngitlab.greendatasoft.ru\nсоздается соответствующее issue, а в\nсистеме тикетов\nзаполняется экземпляр типа объекта \"Внутреннее issue\" [INTERNAL_ISSUES], в котором добавляется ссылка на созданное issue, а также указывается требуемая \"Дата реализации/исполнения\".\nНомер issue создаваемого экземпляра типа объекта \"Внутреннее issue\" рассчитывается автоматически из прикрепляемой ссылки на issue с сайта gitlab.greendatasoft.ru.\nНа сайте\ngitlab.greendatasoft.ru\nсозданное issue передается на исполнение продуктовой команде, а также определяется статус issue.\nСтатус issue - это стадия выполнения поставленной задачи.\nПродуктовая команда - это команда специалистов (Разработчики, Тестировщики, Аналитики и т.д.) компании GreenData, работающая по направлению конкретного продукта.\nДанные значения посредством настроенного\nETL-процесса\nпереносятся в систему планирования, однако не обновляются в системе тикетов. В свою очередь значение даты реализации/исполнения, указанное в системе тикетов, не передается в систему планирования.\nТаким образом появляется необходимость в настройке передачи данных между объектами типа \"Git.Task\"\nприложения A\nи объектами типа \"Внутреннее issue\"\nприложения B\n, в результате которой экземпляры типов объекта в системах планирования и тикетов будут идентичны. Для реализации данной настройки используется двухсторонняя упрощенная интеграция.\nДля сохранения значений синхронизируемых объектов, переданных из одной системы в другую, необходимо использовать типы объектов с одинаковыми\nUUID\n(это означает, что тип объекта, созданный в одном приложении, должен быть перенесен в другое посредством обновлений\n(GUF-файлов)\nлибо с использованием функции\nextType\nв редакторе алгоритмов после настройки подключения между приложениями).\nНастройка подключения между приложениями GreenData\nДля настройки двусторонней упрощенной интеграции между приложениями A и B требуется в каждом из приложений предоставить пользователю внешнего приложения специальный токен и url приложения, а также настроить подключение к внешнему приложению по предоставленному токену и ссылке на приложение.\nДля предоставления Hook токена можно перейти в раздел \"Пользователи\", последовательно выбрав пункты меню: Администрирование→ Управление доступом→ Пользователи.\nВ открывшемся реестре перейти на готовую карточку пользователя либо\nсоздать новую\n, после чего в блоке \"Дополнительно\"\nсоздать пользовательский токен\n.\nПри создании токена указывается наименование и пользователь токена, при необходимости можно заменить начало и конец периода действия, а также указать максимальное количество аутентификаций по токену.\nНа данном этапе\nдо сохранения\nэкземпляра из поля \"Значение\" требуется скопировать автоматически сформированный с помощью методик шифрования\nключ пользователя\n.\nПосле сохранения экземпляра значение токена будет скрыто системой\n.\nТаким образом в\nприложении A\nформируется Hook токен для пользователя\nприложения B\n, а в\nприложении B\nформируется Hook токен для пользователя\nприложения A\n.\nДалее в каждом из приложений необходимо открыть\nреестр типа\n\"Подключение к внешнему приложению\" [SYS_CONNECTION_EXT] и\nсоздать новый экземпляр\nподключения к внешнему приложению, указав параметры настройки:\nнаименование подключения;\nURL внешнего приложения, к которому необходимо настроить подключение;\nпользовательский Hook токен, ранее сформированный в приложении, к которому настраивается подключение.\nЗначение токена задается посредством создания экземпляра типа\n\"Секретная переменная\"\n.\nшифрование токена (при необходимости).\nВ\nприложении A\nсоздается подключение, в котором указывается URL\nприложения B\nи токен, сформированный в\nприложении\nB.\nВ\nприложении B\nсоздается подключение, в котором указывается URL\nприложения A\nи токен, сформированный в\nприложении A\n.\nПодключение к системе тикетов, создаваемое в\nприложении A\n, обозначим как \"Подключение к стенду партнеров\", а наименование подключения к системе планирования, создаваемое в\nприложении B\n, укажем как \"Интеграция с gd_platform\".\nНастройка интеграции\nВ\nприложении A\nсистемы планирования создается\nалгоритм\nинтеграции, который может принять следующий вид:\nПодробнее про алгоритм.\nДля получения коллекции объектов системы тикетов используется функция\nextObjects\n, при вызове которой указывается созданное \"Подключение к стенду партнеров\", после чего выбирается тип объекта \"Внутреннее issue\" системы тикетов и необходимые атрибуты типа.\nДалее при помощи функции\nforEach\nв алгоритме реализован цикл по всем обращениям системы тикетов для поиска экземпляра типа \"Внутреннее issue\" соответствующего по номеру issue экземпляру типа \"Git.Task\" системы планирования. Для этого проводится ряд проверок, при выполнении хотя бы одного условия которых, посредством функции\ncontinue\nосуществится переход к следующей итерации. Таким образом исключаются объекты, у которых:\nне заполнен номер issue системы тикетов;\nдля объекта системы тикетов не найден объект системы планирования с равнозначным номером issue;\nнайдено более одного совпадающего номера issue между системами.\nПри этом для получения коллекции объектов системы планирования используется функция\nobjectsWithOptions\n, при вызове которой выбирается тип объекта \"Git.Task\", функцией\nfilterAlg\nзадаётся фильтрация объектов, а также указывается атрибут типа \"Обещанный внешний срок реализации\".\nТаким образом, если заданные условия будут ложными — это будет означать, что в системах найдена пара объектов, имеющих одинаковые номера issue. После чего при помощи функции\nattrByVar\n:\nв атрибут \"Обещанный внешний срок реализации\" типа объекта \"Git.Task\" в системе планирования передается значение атрибута \"Дата реализации/исполнения\" типа объекта \"Внутреннее issue\" системы тикетов;\nлогическим атрибутам \"Имеются внешние обязательства\" и \"Учтено в системе тикетов\" типа объекта \"Git.Task\" в системе планирования присваивается значение\ntrue\n;\nатрибуту системы тикетов \"Команда (интеграции)\" передается значение атрибута системы планирования \"Команда\";\nатрибуту системы тикетов \"Статус (интеграции)\" передается значение атрибута системы планирования \"Состояние объекта\";\nлогическому атрибуту \"Учтено в системе планирования\" типа объекта \"Внутреннее issue\" в системе тикетов присваивается значение\ntrue\n.\nДля завершения синхронизации необходимо сохранить внесенные изменения при помощи функции\nsave\n.\nПримерное время выполнения алгоритма с текущим набором данных занимает около 50 минут.\nПосле выполнения алгоритма интеграции в карточке экземпляра типа объекта \"Внутреннее issue\" будут автоматически заполнены поля в разделе \"Настройка интеграции\":\nА в систему планирования передадутся указанные в алгоритме значения атрибутов:\nСинхронизация типов\nНеобходимо учитывать возможность добавления значений объектных атрибутов в обеих системах и для корректности алгоритма интеграции синхронизировать данные экземпляров используемых справочников.\nВ рамках данного примера требуется синхронизация типа объекта \"Команда\" [TYPE_TEAM] и типа объекта \"Состояние объекта\" [SYS_STATE], на основе которых созданы одноименные объектные атрибуты, участвующие в интеграции.\nДля синхронизации данных используются типы объектов с одинаковыми\nUUID\n.\nВ алгоритме интеграции между объектами также синхронизируются данные даты реализации/исполнения задачи и логических атрибутов, синхронизация данных типов объекта не требуется, т.к. в данных типах используются только базовые значения: Дата, true/false.\nДля этого в каждой из систем создается алгоритм синхронизации с использованием функции\nextObjects\n.\nАлгоритм синхронизации в системе тикетов может иметь следующий вид:\nКод реализации\n// получение экземпляров команды\ndef\nteams :\n= extObjects(Интеграция с gd_platform, Команда, Наименование)\nfor\n(\ndef\nteam :\nteams) {\ndef\nlocalTypeTeams :\n= extObjToLocal(team)\nsave(localTypeTeams)\n}\n// получение экземпляров статуса\ndef\nstatus :\n= extObjects(Интеграция с gd_platform, Состояние объекта, Наименование)\nprintout (status.size())\nfor\n(\ndef\nstatus_need :\nstatus) {\nif\n(status_need.Идентификатор !=\n\"NEW\"\nand status_need.Идентификатор !=\n\"ARCHIVE\"\n) {\ndef\nlocalTypeStatus :\n= extObjToLocal(status_need)\nsave(localTypeStatus)\n}\n}\ngroovy\nCopied!\nАлгоритм синхронизации с системе планирования может быть записан следующим образом:\nКод реализации\n// Получение экземпляров команды\ndef\nteams :\n= extObjects(Подключение к стенду партнеров, Команда, Наименование)\nfor\n(\ndef\nteam :\nteams) {\ndef\nlocalTypeTeams :\n= extObjToLocal(team)\nsave(localTypeTeams)\n}\n// Получение экземпляров статуса\ndef\nstatus :\n= extObjects(Подключение к стенду партнеров, Состояние объекта, Наименование)\nfor\n(\ndef\nstatus1 :\nstatus) {\nif\n(status1.Идентификатор =\n\"NEW\"\nand status1.Идентификатор =\n\"ARCHIVE\"\n) {\ndef\nlocalTypeStatus :\n= extObjToLocal(status_need)\nsave(localTypeStatus)\n}\n}\ngroovy\nCopied!\nЗапуск алгоритмов осуществляется автоматически по\nрасписанию запуска действий\n.",
  "source": "https://docs.greendata.ru/platform/ru/integration-example-on-planning-tickets.html"
}