{
  "title": "Data structures",
  "text": "Was this article helpful?\nYes\nNo\nThank you for rating the article!\nBy leaving more detailed feedback, you help us improve the documentation\nComment on the rating\nContact information (optional)\nAttachments\nAdd file\nCancel\nSubmit\nData structures\nTemporary data structures can be useful for algorithmic actions. These structures allow the algorithm to fix a set of elements (scalar values, objects, instances) and organize the cycles of iterating or data processing. The structures are based on the capabilities of Groovy programming language and mostly imply the manual code input.\nTypes of structures\nUsing the coding terminology the data structures can be called as \"arrays\", \"multidimensional arrays\", \"dynamic lists\", \"hash tables\", \"associative arrays\", \"data sets\", \"lists\", \"hashes\", etc.\nAll structures have functional features and elements. An\nelement\nof the structure may not only be represented as a scalar value (e.g., number 120) but also as a System object of any type (e.g., application example) or other nested structure.\nLogical data structures\nAt the level of completing application task fundamentally different types of logical data structures are:\narray\n- a structure with access to elements by index;\nhash\n- a structure that provides access by unique keys;\nqueue\n- consists of \"add to the end\" and \"take from the beginning\" methods;\nstack\n- consists of \"add to the top\" and \"take from the top \" methods;\nlinked list\n- consists of elements with a link to another element;\ntree\n- a structure with a set of directions to other elements.\nPhysical data structures\nOn the implementation level, logical structures are a combination of a physical structure and specific methods. The work of the analyst requires the understanding of the following structures:\nstatic arrays\n- contain a fixed number of elements;\ndynamic arrays\n- expandable sets can be replenished and change the composition of elements;\nhashes/associative arrays\n- consist of elements accessible by unique keys, can be modified.\nIn the practice of data automation, it is strongly recommended to use dynamic structures capable of changing the composition of elements (supporting replenishment and deletion)..\nThe program code implementing work with structures can be written in several ways. The examples in this article provide the compact way of writing algorithmic commands.\nStatic array\nAccess to the static array elements implies initial declaration of the array dimension with an explicit indication of the number of elements. The dimension of the static array can be obtained by the\nlength\nproperty.\nThe\nObject\nis the most versatile type of an array, as it can store elements of any type. Specifying other types (e.g. String) means that all elements of the array will match the specified type.\nNote that an array filling is completed through accessing the arrayâ€™s elements in assignment mode, not through addition methods mode. Array elements than have not been filled with values are considered empty.\nExample of work with static array data\nCode example\ndef d1 := new Object[5]\nd1[0] := 100\nd1[1] := 200\nd1[4] := 500\nprintout (\" Structure: \" + d1)\nprintout (\" Element with index 1: \" + d1[1])\nprintout (\" Total number of elements: \" + d1.length)\nThe array elements are sorted by an arithmetic iteration from first to last.\nExample of cyclic processing of a typed array (String type)\nCode example\ndef arr := new String[3]\narr[0] := \"New York City\"\narr[1] := \"Louisville, Kentucky\"\narr[2] := \"Sarasota, Florida\"\nprintout (\"--- Starting array ---\")\nprintout (\"Array as structure: \" + arr)\nprintout (\"--- Iteration by elements ---\")\nfor(def i = 0; i < arr.length; i++) {\nprintout (\"Element with index \" + i + \": \" + arr[i])\n}\nIn multidimensional arrays, elements are accessed via a composite index. At the same time, nested loops are often used for cyclic iteration of elements.\nExample of cyclic filling of a two-dimensional array (filling the multiplication table 10*10)\nCode example\ndef arr0 := new Object[10][10]\nprintout (\"--- Nested array cycles ---\")\nfor(def i = 0; i < arr0.size(); i++) {\nfor(def j = 0; j < arr0[i].size(); j++) {\narr0[i][j] = (i + 1)*(j + 1)\n}\n}\nData processing cycle can be effectively used for other types of arrays.\nDynamic array\nA dynamic (expandable) array provides the ability to change the composition of elements:\nadd\n- adding an element to the array;\nremove\n- deleting an element (with the revision of the order);\nsize\n-a method for obtaining the actual dimension (number of elements).\nExample of manipulations with dynamic array data\nCode example\ndef arr := []\narr.add(\"New York City\")\narr.add(\"San Jose, California\")\narr.add(\"Louisville, Kentucky\")\nprintout (\"--- Primary array ---\")\nprintout (arr)\nprintout (\"Total number of elements: \" + arr.size())\nprintout (\"Element by index 1: \" + arr[1])\narr.add(\"Houston, Texas\")\narr.remove(\"San Jose, California\")\nprintout (\"--- Modified array ---\")\nprintout (arr)\nprintout (\"--- Reverse array ---\")\narr := arr.reverse()\nprintout (arr)\nExample of a nested array (emulation of multidimension)\nCode example\ndef arr1 := []\ndef arr2 := []\narr2.add(\"Louisville\")\narr2.add(\"Lexington\")\narr2.add(\"Ashland\")\narr1.add(\"Commonwealth of Kentucky\")\narr1.add(arr2)\narr1.add(arr2)\narr1[1][1] = \"New\"\narr1.add(\"State of Tennessee\")\narr1.add(\"State of Missouri\")\nprintout (\"--- Result ---\")\nprintout (\"Main array: \" + arr1)\nprintout (\"Start element: \" + arr1[0])\nprintout (\"Element in main set: \" + arr1.size())\nprintout (\"--- Nested array ---\")\nprintout (\"Array composition: \" + arr1[1])\nprintout (\"Total number of elements: \" + arr1[1].size())\nprintout (\"Central element: \" + arr1[1][1])\nHash\nHashSet\nclass is used when organizing data into a hash (hash table). It allows to maintain a\nunique\nand unordered set of elements. The key methods of work are:\nadd\n- adding a unique element;\nremove\n- removing an existing element.\nIt is necessary to pay attention to the rule of observing the singularity of the data set.\nFor example, an attempt to insert an equivalent (duplicate) of an existing element into the hash cannot be executed and will be ignored.\nExample of calibration of the simplest hash composition\nCode example\ndef hs := new HashSet()\nhs.add(\"New York City\")\nhs.add(\"Louisville, Kentucky\")\nhs.add(\"San Jose, California\")\nhs.add(\"Houston, Texas\")\nprintout (\"--- Start array ---\")\nprintout (hs)\nhs.add(\"Louisville, Kentucky\")\nhs.remove(\"Houston, Texas\")\nprintout (\"--- Modified set ---\")\nprintout (hs)\nHashMap\nset is a specific technical data set type, which allows to manipulate elements according to their unique keys and based on methods:\nput\n- adding an element (key and value);\nget\n- implementing an element (by key).\nWhen processing hash data, a specific \"for each element\" loop type is used, which allows user to extract the key and the value of the element by the actual key.\nExample of work with data (by keys) in the HashMap structure\nCode example\ndef hm := new HashMap()\nhm.put(495, \"New York City\")\nhm.put(342, \"Louisville, Kentucky\")\nhm.put(3812, \"Sarasota, Florida\")\nhm.put(3452, \"Houston, Texas\")\nprintout (\"--- Primary structure ---\")\nprintout (hm)\nprintout (\"--- Exhaustive ---\")\nfor(def elem : hm) {\nprintout (elem)\nprintout (\"Pair \" + elem.key + \" and \" + elem.value)\n}\nprintout (\"--- Access cycle by key ---\")\nfor(def k : hm.keySet()) {\nprintout (\"For key \" + k + \" value \" + hm.get(k))\n}\nStack\nWorking with data in stack mode involves declaring an expandable array\nArrayDeque\n. Such interaction requires the usage of specialized methods:\npush\n- adding elements to a stack;\npop\n- extracting elements from a stack.\nExample of work with an expandable array in stack mode\nCode example\ndef st := new ArrayDeque()\nst.push(\"New York City\")\nst.push(\"San Jose, California\")\nst.push(\"Louisville, Kentucky\")\nprintout (\"--- Primary stack ---\")\nprintout (st)\ndef elemcount := st.size()\nprintout (\"Number of elements: \" + elemcount)\ndef elem := st.pop()\nprintout (\"--- Modified stack ---\")\nprintout (st)\nprintout (\"Extracted element: \" + elem)\nprintout (\"Start element: \" + st[0])\nprintout (\"Actual amount: \" + st.size())\nQueue\nWorking with data in queue mode involves declaring an expandable array\nArrayDeque\n. Such interaction requires the usage of specialized methods:\noffer\n- adding elements to the end of the queue;\npoll\n- extracting an element from the start of the queue.\nExample of work with an expandable array in queue mode\nCode example\ndef st := new ArrayDeque()\nst.offer(\"New York City\")\nst.offer(\"Sarasota, Florida\")\nst.offer(\"Louisville, Kentucky\")\nprintout (\"--- Start queue ---\")\nprintout (st)\ndef elemcount = st.size()\nprintout (\"Number of elements: \" + elemcount)\ndef elem = st.poll()\nprintout (\"--- Modified queue ---\")\nprintout (st)\nprintout (\"Extracting elements: \" + elem)\nprintout (\"Actual amount: \" + st.size())\nprintout (\"--- Access elements ---\")\nprintout (\"Start element: \" + st.getFirst())\nprintout (\"End element: \" + st.getLast())\nprintout (\"Element with index 0: \" + st[0])\nSearching and checking\nThere are a few ways to determine how data relates to a particular set. These methods depend on the chosen physical structure.\nAn array search is provided by directives:\ncontains - whether contains in the data set;in - whether the part of the array;indexOf - listing position.\nCode example\nprintout (\"--- Array search ---\")\ndef arr := []\narr.add(\"New York City\")\narr.add(\"Louisville, Kentucky\")\nif(arr.contains(\"Louisville, Kentucky\")) {\nprintout (\"Element found\")\n}\nif(!arr.contains(\"San Jose, California\")) {\nprintout (\"Not found in array\")\n}\nif(\"London\" in arr) {\nprintout (\"Found in array\")\n}\nprintout (\"Found element position: \" + arr.indexOf(\"Louisville, Kentucky\"))\nprintout (\"Not found element position: \" + arr.indexOf(\"Sacramento, California\"))\nMethods for searching in hash structures:\ncontainsKey\n- whether contains an element (by key);\ncontainsValue\n- whether contains an element (by value).\nCode example\ndef hm := new HashMap()\nhm.put(495, \"New York City\")\nhm.put(342, \"Louisville, Kentucky\")\nif(hm.containsKey(342)) {\nprintout (\"Found element by key\")\n}\nif(hm.containsValue(\"New York City\")) {\nprintout (\"Found element by value\")\n}\nprintout (\"--- Check for element update ---\")\nif(hm.containsKey(342)) {\nif(hm[342] == \"Louisville, Kentucky\") {\nhm[342] = \"city of \" + hm[342]\n}\n}\nprintout (hm)",
  "source": "https://docs.greendata.ru/platform/en/data-structures.html"
}