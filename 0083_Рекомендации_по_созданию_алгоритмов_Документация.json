{
  "title": "Рекомендации по созданию алгоритмов",
  "text": "Была ли статья полезной?\nДа\nНет\nСпасибо за вашу оценку!\nОставляя более подробный отзыв, вы помогаете нам улучшать документацию\nКомментарий к оценке\nКонтактная информация (необязательно)\nВложения\nДобавить файл\nОтменить\nОтправить\nРекомендации по созданию алгоритмов\nПроцесс разработки алгоритмов является творческим. Однако кроме творчества в деятельности разработчика присутствуют правила и рекомендации, которые нужно стараться соблюдать. Несоблюдение правил считается \"\nдурным тоном\n\" и негативно сказывается как на самом алгоритме, так и карьере его автора.\nНаименование и расположение алгоритмов\nВ платформе GreenData присутствует множество разных алгоритмов. Поэтому появление нового алгоритма пользователя предполагает соблюдение следующих правил:\nНаименование алгоритма должно быть осмысленным\nи опираться на ключевое действие (содержать глагол \"получить\", \"рассчитать\"…​)\nКорректно: \"Заполнение наименования заявки\".\nОшибочно: \"Наименование заявки\".\nСмысловой идентификатор алгоритма\nЕсли алгоритм относится к какому-то блоку, то в начале добавляется префикс блока. Например, алгоритму с наименованием \"Лимиты. Расчет VaR по портфелю\" следует задать идентификатор \"LIM_VAR_CALC_ALG\".\nАлгоритм должен располагаться в папке\nАвтором предварительно создается папка и (при необходимости) вложенные папки,\nв которых и будут размещаться тематические алгоритмы\nАлгоритмы, помещенные в корневое пространство хранилища платформы считаются тестовыми и могут быть удалены.\nКомментирование\nКомментарии должны использоваться:\nНад основным алгоритмом (блок краткого описания);\nПример описания над кодом алгоритма:\nРядом со сложными неочевидными конструкциями языка;\nВ режиме отладки алгоритма (см. в статье\nРекомендации по отладке алгоритмов\n).\nНаглядность кода алгоритма\nОсновные требования к наглядности кода:\nИспользование формата вложенности\nДля наглядности вложенные операторы должны выделяться смещением (вправо) относительно основных операторов. Среда редактирования помогает автоматически расставлять символы смещения (табуляторы).\nНаглядность и соразмерность экрану\nНастоятельно не рекомендуется использовать в алгоритме длинные строки операторов или выражения, которые не умещаются на экране. Следует разделить сложное выражение (уходящее за границы редакционного поля) на несколько более компактных фрагментов/операторов.\nДублирующие конструкции\nЕсли в основном алгоритме требуется выполнение схожих (или эквивалентных) фрагментов кода, следует вынести их во вспомогательный алгоритм, вызывая его нужное количество раз посредством функции\nalg\n.\nИспользуйте вложенные алгоритмы для повторяющегося простого кода. Это позволит не только улучшить читаемость кода, но и минимизировать риски изменения архитектуры.\nИзлишние директивы\nИзлишними (паразитными) директивами языка считаются команды, написание которых является излишним. Их отсутствие сделает код более компактным и не скажется на функциональности алгоритма.\nНаиболее частыми паразитными конструкциями считаются:\nCравнение с булевыми константами\nИспользовать сопоставление значения с true/false или возвращать true/false в алгоритме фильтрации нерационально, так как условие может быть записано более компактно.\nЯвное использование директивы return\nВместо написания директивы return достаточно последним оператором алгоритма указать идентификатор, значение которого и будет возвращено.\nПреобразования паразитных конструкций:\nКонстанты\nКонстанты – это неизменяемые значения. Дурным тоном считается явное использование констант в середине кода. Все константы должны быть в аналитических диапазонах, таблицах коэффициентов или в справочниках.\nВ несложных случаях\nможно объявлять константы в начале кода в виде переменных\n. Это позволит в дальнейшем не притрагиваться к основному коду алгоритма, а вносить возможные правки только в верхней (простой и наглядной) части кода.\nУправления значением константы через ранее объявленную переменную:\nПроизводительность\nПроизводительность алгоритмов может измеряться в количестве вычислительных итераций (зависит от логики реализации алгоритма) и времени исполнения. Время\nЗаготовка для оценки производительности:\n// фиксируем момент времени - в начале алгоритма\ndef time1 := new Date()\ndef t1_ms := time1.format(\"Ms\").toInteger()\ndef t1_ss := time1.format(\"ss\").toInteger()\ndef t1_mm := time1.format(\"mm\").toInteger()\ndef t1_hh := time1.format(\"HH\").toInteger()\ndef time1_num := 60*60*1000*t1_hh + 60*1000*t1_mm + 1000*t1_ss + t1_ms\n// ... основной код  алгоритма ...\n// фиксируем момент времени - в конце алгоритма\ndef time2 := new Date()\ndef t2_ms := time2.format(\"Ms\").toInteger()\ndef t2_ss := time2.format(\"ss\").toInteger()\ndef t2_mm := time2.format(\"mm\").toInteger()\ndef t2_hh := time2.format(\"HH\").toInteger()\ndef time2_num := 60*60*1000*t2_hh + 60*1000*t2_mm + 1000*t2_ss + t2_ms\n// вычисляем фактическое время исполнения\ndef exec_time := time2_num - time1_num\nprintout (\"Длительность исполнения (мс): \" + exec_time)\nПроизводительность алгоритмов зависит от множества факторов. Наиболее важные ситуации, снижающие производительность алгоритмов, приведены ниже:\nИспользование более двух вложенных циклов\n.\nНижним порогом эффективности алгоритмов упорядочивания и сортировки является количество итераций N*N (где N размерность набора данных). Если алгоритм для перебора данных и принятия решения требует большего объема действий, то его логика должна быть пересмотрена.\nНеоднократная подгрузка\nодних и тех же данных во вложенных циклах.\nСледует стараться загружать данные однократно (например, в коллекцию) и в дальнейшем организовывать циклы по уже сформированной коллекции. Хотя количество итераций останется неизменным, ресурсоемкость обращения к данным значительно уменьшится.\nМножественные вызовы\nсхожего функционала в коде или циклах.\nНеобходимо рассмотреть возможность однократного вызова функции и фиксации результата ее исполнения в идентификаторе. Все последующие операции и сверки должны выполняться именно с идентификатором.\nРабота с фиктивными справочниками\n(\"Да\"/\"Нет\").\nДля реализации управленческой логики следует стараться пользоваться типом boolean, а не подгружать внешние справочники со схожими данными. Значений true и false вполне достаточно для автоматизации взаимоисключающей логики.\nЗапреты и ограничения\nАлгоритмы вправе вносить изменения в свойства не всех объектов.\nИспользование алгоритмов для установки значений маршрутного объекта на бизнес-процессе\nСТРОГО ЗАПРЕЩЕНО\n. Алгоритмическое воздействие на маршрутный объект ведет к блокировке на уровне базы данных (помимо основной транзакции возникает конкурирующая транзакция сохранения объекта).\nДля воздействия на маршрутный объект необходимо использовать специализированный метод \"\nВычислить атрибут\n\".",
  "source": "https://docs.greendata.ru/platform/ru/recommendations-for-creating-algorithms.html"
}